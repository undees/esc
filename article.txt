Testing Embedded User Interfaces
================================

This is an introductory talk--has to be.  Embedded devices are so
different from one another.

Desktop testing is fairly routine.  Capture/playback, GUI spidering,
or just scripted.  (Academia hints at more scalable testing.) Basic
idea: drive the GUI, check the response.  Combat fragility by keeping
the top-level tests in the language of the problem domain--which also
helps with readability.


Case Studies
------------

We're going to look at several variations on the theme of testing
embedded interfaces, from full-on desktop systems down through simple
one-trick-pony devices that communicate only through buttons and LEDs.

Embedded Desktop GUI
~~~~~~~~~~~~~~~~~~~~

Let's take a first tiny step from the desktop world to the embedded
world: packaging a full desktop OS inside a device.  Consider a
measurement instrument running something like Windows Embedded
Standard, running a user interface built on any of the common APIs
(Win32, WinForms, WPF).

Because we have the full power of a desktop system available, we can
install nearly any dependency we need onto our development hardware.
If we want to use a particular GUI automation framework or a favorite
scripting language, we can.

Let's look at one possible way this scenario can play out.  Imagine
you're testing a GUI that looks like this:

(figure)

If you're sketching out how you want the system to behave, you might
come up with something like this:

--------------------------------------------------------------------
Feature: Waveform Type

  In order to drive my circuit
  As an engineer
  I want to control the geometry of the signal

  Scenario: Sine Wave
    Given a waveform
    When I set the Waveform Type to "Sine Wave"
    Then the Duty Cycle setting should be disabled
--------------------------------------------------------------------

We're starting with a plain-language, non-programmer-speak description
of the behavior we want--including an explanation of who this feature
is for, and why they want it.

At this point, the traditional testing approach would have you
translate this example into a programming language. But we're going to
use a test framework that will be able to drive our application
straight from this English description. That framework is called
Cucumber.

TODO: Cucumber background

Each of the steps in the scenario--each +Given+, +When+, or +Then+--is
going to call a little piece of glue code called a _step
definition_. These can be written in just about anything. Ruby is
certainly the most popular choice, since it's what Cucumber happens to
be written in. But you can also code your step definitions in Java,
C#, JavaScript, Python, and other languages--including, as we'll see
later, Tcl.

For this particular case, we're going to use C#, because it's the
implementation language for a popular open-source GUI automation
framework called White.footnote:[http://white.codeplex.com]

Before we hook things up to Cucumber, let's see how we'd mechanically
perform this sequence of GUI operations in a standalone program
calling the White APIs:

[source,C#]
--------------------------------------------------------------------
class ExampleProject
{
    static int Main()
    {
        var app = Application.Attach("waveform.exe");
        var win = app.GetWindows().First;

        var waveformType =
            win.Get<ComboBox>(
                SearchCriteria.ByAutomationId("WaveformType"));

        waveformType.Select("Sine Wave");

        var dutyCycle =
            win.Get<TextBox>(
                SearchCriteria.ByAutomationId("DutyCycle"));

        Console.WriteLine("Duty Cycle is " +
                          (dutyCycle.Enabled ? "enabled" : "disabled"));
    }
}
--------------------------------------------------------------------

TODO: Wrap this in step defs

TODO: Run it from Cucumber

Putting the test code directly on the hardware being tested has a few
drawbacks:

* Launching a test requires manually interacting with the hardware.
* Updating a test requires copying the new test code down to the
  hardware.
* Building a test report requires gathering results from the hardware.

Granted, some of these inconveniences could be overcome with a little
automation.  Even so, if we want to spend our time as developers,
rather than system administrators, it's useful to keep the frequency
of interaction with our devices at a minimum.

TODO: Explain cucumber.wire

TODO: Show how to put the step defs on the hardware

Touch-Screen GUI
~~~~~~~~~~~~~~~~

Show the basics of how Cucmber works.  Explain Win32 API connection.

[quote, Bryan O'Sullivan, blog comment (2009)]
____________________________________________________________________
Oh wow.  I never knew that Rubyists had a Cobol fetish.
____________________________________________________________________


Physical UI
~~~~~~~~~~~

Remote commands to simulate button pushes.

What to do in embedded GUIs? Developer hooks! Show TCP-driven GUI
example, which just happens to be reusable as a test for the official
PI.  All but the most restrictive environments support some kind of PI.


Experiment
----------

How low can it scale? With the official wire protocol, you can drive
anything with TCP.  Or you can use whatever homebrewed protocol your
device supports, and write the glue code yourself.  Demo with something
really cheesy built on an Arduino:

--------------------------------------------------------------------
Given I am ambivalent
When my mood improves
Then I am happy
--------------------------------------------------------------------

An example step definition:

[source,ruby]
--------------------------------------------------------------------
When /^my mood improves$/ do
  @dut.increase_happiness
end
--------------------------------------------------------------------

5 LEDs representing moods, up/down buttons.  Simulate by sending +/- to
serial port.  Query LED state as bit mask by sending ? character.  Get
good correspondence between GUI / serial, then test largely w/o
hardware.

Another example: use multiline strings to represent menu text on the
four-line display of an LCD---that's what I wish I'd done way back
when.  Similar examples: lawn sprinkler controllers, home automation,
etc.

Now we've run the gamut from ``desktop OS shoehorned into instrument,''
through ``program running on embedded OS'' to ``barely anything running
at all.'' Surely your project fits somewhere on this spectrum.  Well,
except that there's some kind of vertical axis.  Avionics projects have
their own stringent model-checking requirements, for instance.


Polyglot Testing
----------------

Just for fun, a low-end ``Cucumber lite'' in Tcl.  But there's really no
need.  Cucumber can drive Tcl directly.

Thoughts
--------

Hooks are the single place where a little developer time has a huge
impact.  I wasn't sure enough of myself to pester people to add this
stuff at first.

Decide what you want from your tests.  Exercise the GUI? Top-to-bottom
testing? Document the requirements?

Choose a notation that lets you express your intent clearly.

Think of BDD as a rallying cry or an inspirational card on your desk,
not as a checklist of practices.
