Testing Embedded User Interfaces
================================

This is an introductory talk--has to be.  Embedded devices are so
different from one another.

Desktop testing is fairly routine.  Capture/playback, GUI spidering,
or just scripted.  (Academia hints at more scalable testing.) Basic
idea: drive the GUI, check the response.  Combat fragility by keeping
the top-level tests in the language of the problem domain--which also
helps with readability.


Case Studies
------------

We're going to look at several variations on the theme of testing
embedded interfaces, from full-on desktop systems down through simple
one-trick-pony devices that communicate only through buttons and LEDs.

Embedded Desktop GUI
~~~~~~~~~~~~~~~~~~~~

Let's take a first tiny step from the desktop world to the embedded
world: packaging a full desktop OS inside a device.  Consider a
measurement instrument running something like Windows Embedded
Standard, running a user interface built on any of the common APIs
(Win32, WinForms, WPF).

Because we have the full power of a desktop system available, we can
install nearly any dependency we need onto our development hardware.
If we want to use a particular GUI automation framework or a favorite
scripting language, we can.

Let's look at one possible way this scenario can play out.  Imagine
you're testing a GUI that looks like this:

(figure)

If you're sketching out how you want the system to behave, you might
come up with something like this:

--------------------------------------------------------------------
Feature: Waveform Type

  In order to drive my circuit
  As an engineer
  I want to control the geometry of the signal

  Scenario: Sine Wave
    Given a waveform
    When I set the Waveform Type to "Sine Wave"
    Then the Duty Cycle setting should be disabled
--------------------------------------------------------------------

We're starting with a plain-language, non-programmer-speak description
of the behavior we want--including an explanation of who this feature
is for, and why they want it.

At this point, the traditional testing approach would have you
translate this example into a programming language. But we're going to
use a test framework that will be able to drive our application
straight from this English description. That framework is called
Cucumber.

TODO: Cucumber background

Each of the steps in the scenario--each +Given+, +When+, or +Then+--is
going to call a little piece of glue code called a _step
definition_. These can be written in just about anything. Ruby is
certainly the most popular choice, since it's what Cucumber happens to
be written in. But you can also code your step definitions in Java,
C#, JavaScript, Python, and other languages--including, as we'll see
later, Tcl.

For this particular case, we're going to use C#, because it's the
implementation language for a popular open-source GUI automation
framework called White.footnote:[http://white.codeplex.com]

Before we hook things up to Cucumber, let's see how we'd mechanically
perform this sequence of GUI operations in a standalone program
calling the White APIs:

[source,C#]
--------------------------------------------------------------------
class ExampleProject
{
    static int Main()
    {
        var app = Application.Attach("waveform.exe");
        var win = app.GetWindows().First;

        var waveformType =
            win.Get<ComboBox>(
                SearchCriteria.ByAutomationId("WaveformType"));

        waveformType.Select("Sine Wave");

        var dutyCycle =
            win.Get<TextBox>(
                SearchCriteria.ByAutomationId("DutyCycle"));

        Console.WriteLine("Duty Cycle is " +
                          (dutyCycle.Enabled ? "enabled" : "disabled"));
    }
}
--------------------------------------------------------------------

We've seen what the top-level Cucumber test script looks like, and
what low-level C# code to write to manipulate the on-screen controls.
But how do we connect the two together?  With C# attributes.  We put
each test step in its own method, and decorate that with the name of
the step.  The names are regular expressions, so we don't have to
write separate steps for things like +the amplitude should be 100+ or
+the amplitude should be 200+.

Here's the code from above, adapted into a C# class with the correct
attributes:

[source,C#]
--------------------------------------------------------------------
class WaveformSteps
{
    private Application app;
    private Window win;

    [Given("^a waveform$")]
    public void AWaveform()
    {
        app = Application.Attach("waveform.exe");
        win = app.GetWindows().First;
    }

    [When("^I set the Waveform Type to \"([^\"]*)\"$"]
    public void ISetTheWaveformTypeTo(string value)
    {
        var waveformType =
            win.Get<ComboBox>(
                SearchCriteria.ByAutomationId("WaveformType"));

        waveformType.Select(value);
    }

    [Then("^the Duty Cycle setting should be (.+)$")]
    public void TheDutyCycleSettingShouldBe(string value)
    {
        var wantEnabled = (value == "enabled");

        var isEnabled =
            win.Get<TextBox>(
                SearchCriteria.ByAutomationId("DutyCycle")).Enabled;

        if (isEnabled != wantEnabled)
        {
            throw new Exception(
                "Expected the Duty Cycle setting to be " + value);
        }
    }
}
--------------------------------------------------------------------

When you run a Cucumber test script, Cucumber searches your project's
+features/step_definitions+ directory for the source code to your step
definitions.  This is fine when you're writing your steps in an
interpreted language like Python or JavaScript, but what do we do for
a compiled language like C#?

The answer is that we put a special file called +cucumber.wire+ in the
+step_definitions+ directory, indicating that Cucumber should connect
to compiled code over a TCP port, rather than interpreting source code
directly:

--------------------------------------------------------------------
host: localhost
port: 3901
--------------------------------------------------------------------

The Cuke4Nuke project takes care of launching a server with your
compiled C# step definitions, listening for the names of individual
Cucumber steps to run, running them, and reporting the pass / fail
result:

--------------------------------------------------------------------
C:\MyProject\> cuke4Nuke WaveformSteps.dll
--------------------------------------------------------------------

Putting the test code directly on the hardware being tested has a few
drawbacks:

* Launching a test requires manually interacting with the hardware.
* Updating a test requires copying the new test code down to the
  hardware.
* Building a test report requires gathering results from the hardware.

Granted, some of these inconveniences could be overcome with a little
automation.  Even so, if we want to spend our time as developers,
rather than system administrators, it's useful to keep interaction
with our devices at a minimum.

Fortunately, as you may have guessed from seeing the contents of the
+cucumber.wire+ file, you're free to specify a server running on a
different machine.

--------------------------------------------------------------------
host: mytesthardware.example.com
port: 3901
--------------------------------------------------------------------

Now, you can copy your step definition DLL down to the hardware and
run the server there.  Rather than using the +cuke4nuke.bat+ wrapper
script (which also runs the tests), you'll want to run the server
+.exe+ directly:

--------------------------------------------------------------------
C:\MyHardware\> Cuke4Nuke.Server.exe WaveformSteps.dll
--------------------------------------------------------------------

On your PC, you then use just the regular +cucumber+ batch file to run
the tests:

--------------------------------------------------------------------
C:\MyProject\> cucumber
--------------------------------------------------------------------

TODO: Show how to put the step defs on the hardware

Touch-Screen GUI
~~~~~~~~~~~~~~~~

Show the basics of how Cucmber works.  Explain Win32 API connection.

[quote, Bryan O'Sullivan, blog comment (2009)]
____________________________________________________________________
Oh wow.  I never knew that Rubyists had a Cobol fetish.
____________________________________________________________________


Physical UI
~~~~~~~~~~~

Remote commands to simulate button pushes.

What to do in embedded GUIs? Developer hooks! Show TCP-driven GUI
example, which just happens to be reusable as a test for the official
PI.  All but the most restrictive environments support some kind of PI.


Experiment
----------

How low can it scale? With the official wire protocol, you can drive
anything with TCP.  Or you can use whatever homebrewed protocol your
device supports, and write the glue code yourself.  Demo with something
really cheesy built on an Arduino:

--------------------------------------------------------------------
Given I am ambivalent
When my mood improves
Then I am happy
--------------------------------------------------------------------

An example step definition:

[source,ruby]
--------------------------------------------------------------------
When /^my mood improves$/ do
  @dut.increase_happiness
end
--------------------------------------------------------------------

5 LEDs representing moods, up/down buttons.  Simulate by sending +/- to
serial port.  Query LED state as bit mask by sending ? character.  Get
good correspondence between GUI / serial, then test largely w/o
hardware.

Another example: use multiline strings to represent menu text on the
four-line display of an LCD---that's what I wish I'd done way back
when.  Similar examples: lawn sprinkler controllers, home automation,
etc.

Now we've run the gamut from ``desktop OS shoehorned into instrument,''
through ``program running on embedded OS'' to ``barely anything running
at all.'' Surely your project fits somewhere on this spectrum.  Well,
except that there's some kind of vertical axis.  Avionics projects have
their own stringent model-checking requirements, for instance.


Polyglot Testing
----------------

Just for fun, a low-end ``Cucumber lite'' in Tcl.  But there's really no
need.  Cucumber can drive Tcl directly.

Thoughts
--------

Hooks are the single place where a little developer time has a huge
impact.  I wasn't sure enough of myself to pester people to add this
stuff at first.

Decide what you want from your tests.  Exercise the GUI? Top-to-bottom
testing? Document the requirements?

Choose a notation that lets you express your intent clearly.

Think of BDD as a rallying cry or an inspirational card on your desk,
not as a checklist of practices.
