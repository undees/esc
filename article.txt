Testing Embedded User Interfaces
================================

Story Time
----------

My first job out of school was at a small industrial automation
company in Houston.  One of our products was what we called an
Industrial Display Unit--basically a do-it-yourself user interface.
If you wanted to control, say, a grain hopper, you might put the
actual smarts into a PLC, and then use the display unit to put a
configurable face on it.

.Embedded UI
image::images/idu.png[]

As long as your PLC used one of the protocols we supported, like
Modbus, it was pretty easy to customize.  By going in through an
administrator interface, you could set up your own operator menus,
through which you could read or write things like integers or booleans
to the various device registers.

Once you'd defined a couple of menus and assigned a couple of hotkeys,
you might end up with something like this on the 25x4 display:

--------------------------------------------------------------------
       GRAIN PACKAGER
> 1. Hopper   (30%)
  2. Advanced
[OPEN]            [CLOS]
--------------------------------------------------------------------

We had a few notes and sketches on legal pads: ideas on different ways
to represent the menus, and so on.  Imagine for a moment that this was
one of our use cases:

--------------------------------------------------------------------
Given a unit in admin mode
When I set the title to "TESTING"
When I add a boolean register called "Light" at address 4000
And I reset the device
Then the screen should say
  """
           TESTING
  > 1. Light (OFF)

  [TOGL]
  """
--------------------------------------------------------------------

Our notes were just scribbled menu sketches with arrows pointing from
one state to the next.  But they outlined the same kinds of use cases
you see here.

The test cycle for this device was pretty slow by today's standards.
We'd compile the software (making sure we didn't have any 9-character
variable names!), do a few incantations to get it onto the emulator,
start the program, type in the admin password, and try editing a few
menus.

If things didn't work, we'd tweak the code, maybe try hijacking a
corner of the LCD for debug info, and try again.  What I really wish
I'd had back in those days was the foresight to put better developer
hooks in the code.

If we had, we could have turned the use case you see above into
_running code_.

Case Studies
------------

We're going to look at several variations on the theme of testing
embedded interfaces, from full-on desktop systems down through simple
one-trick-pony devices that communicate only through buttons and LEDs.

Embedded Desktop GUI
~~~~~~~~~~~~~~~~~~~~

Desktop testing is fairly routine.  Capture/playback, GUI spidering,
or just scripted.  (Academia hints at more scalable testing.) Basic
idea: drive the GUI, check the response.  Combat fragility by keeping
the top-level tests in the language of the problem domain--which also
helps with readability.

Let's take a first tiny step from the desktop world to the embedded
world: packaging a full desktop OS inside a device.  Consider a
measurement instrument running something like Windows Embedded
Standard, running a user interface built on any of the common APIs
(Win32, WinForms, WPF).

Because we have the full power of a desktop system available, we can
install nearly any dependency we need onto our development hardware.
If we want to use a particular GUI automation framework or a favorite
scripting language, we can.

Let's look at one possible way this scenario can play out.  Imagine
you're testing a GUI that looks like this:

.A desktop GUI
image::images/desktop.png[]

If you're sketching out how you want the system to behave, you might
come up with something like this:

--------------------------------------------------------------------
Feature: Waveform Type

  In order to drive my circuit
  As an engineer
  I want to control the geometry of the signal

  Scenario: Sine Wave
    Given a waveform
    When I set the Waveform Type to "Sine Wave"
    Then the Duty Cycle setting should be disabled
--------------------------------------------------------------------

We're starting with a plain-language, non-programmer-speak description
of the behavior we want--including an explanation of who this feature
is for, and why they want it.

At this point, the traditional testing approach would have you
translate this example into a programming language. But we're going to
use a test framework that will be able to drive our application
straight from this English description. That framework is called
Cucumber.

TODO: Cucumber background

Each of the steps in the scenario--each +Given+, +When+, or +Then+--is
going to call a little piece of glue code called a _step
definition_. These can be written in just about anything. Ruby is
certainly the most popular choice, since it's what Cucumber happens to
be written in. But you can also code your step definitions in Java,
C#, JavaScript, Python, and other languages--including, as we'll see
later, Tcl.

For this particular case, we're going to use C#, because it's the
implementation language for a popular open-source GUI automation
framework called White.footnote:[http://white.codeplex.com]

Before we hook things up to Cucumber, let's see how we'd mechanically
perform this sequence of GUI operations in a standalone program
calling the White APIs:

[source,csharp]
--------------------------------------------------------------------
class ExampleProject
{
    static int Main()
    {
        var app = Application.Attach("waveform.exe");
        var win = app.GetWindows().First;

        var waveformType =
            win.Get<ComboBox>(
                SearchCriteria.ByAutomationId("WaveformType"));

        waveformType.Select("Sine Wave");

        var dutyCycle =
            win.Get<TextBox>(
                SearchCriteria.ByAutomationId("DutyCycle"));

        Console.WriteLine("Duty Cycle is " +
                          (dutyCycle.Enabled ? "enabled" : "disabled"));
    }
}
--------------------------------------------------------------------

We've seen what the top-level Cucumber test script looks like, and
what low-level C# code to write to manipulate the on-screen controls.
But how do we connect the two together?  With C# attributes.  We put
each test step in its own method, and decorate that with the name of
the step.  The names are regular expressions, so we don't have to
write separate steps for things like +the amplitude should be 100+ or
+the amplitude should be 200+.

Here's the code from above, adapted into a C# class with the correct
attributes:

[source,csharp]
--------------------------------------------------------------------
class WaveformSteps
{
    private Application app;
    private Window win;

    [Given("^a waveform$")]
    public void AWaveform()
    {
        app = Application.Attach("waveform.exe");
        win = app.GetWindows().First;
    }

    [When("^I set the Waveform Type to \"([^\"]*)\"$")]
    public void ISetTheWaveformTypeTo(string value)
    {
        var waveformType =
            win.Get<ComboBox>(
                SearchCriteria.ByAutomationId("WaveformType"));

        waveformType.Select(value);
    }

    [Then("^the Duty Cycle setting should be (.+)$")]
    public void TheDutyCycleSettingShouldBe(string value)
    {
        var wantEnabled = (value == "enabled");

        var isEnabled =
            win.Get<TextBox>(
                SearchCriteria.ByAutomationId("DutyCycle")).Enabled;

        if (isEnabled != wantEnabled)
        {
            throw new Exception(
                "Expected the Duty Cycle setting to be " + value);
        }
    }
}
--------------------------------------------------------------------

When you run a Cucumber test script, Cucumber searches your project's
+features/step_definitions+ directory for the source code to your step
definitions.  This is fine when you're writing your steps in an
interpreted language like Python or JavaScript, but what do we do for
a compiled language like C#?

The answer is that we put a special file called +cucumber.wire+ in the
+step_definitions+ directory, indicating that Cucumber should connect
to compiled code over a TCP port, rather than interpreting source code
directly:

--------------------------------------------------------------------
host: localhost
port: 3901
--------------------------------------------------------------------

The Cuke4Nuke project takes care of launching a server with your
compiled C# step definitions, listening for the names of individual
Cucumber steps to run, running them, and reporting the pass / fail
result:

--------------------------------------------------------------------
C:\MyProject\> cuke4Nuke WaveformSteps.dll
--------------------------------------------------------------------

Putting the test code directly on the hardware being tested has a few
drawbacks:

* Launching a test requires manually interacting with the hardware.
* Updating a test requires copying the new test code down to the
  hardware.
* Building a test report requires gathering results from the hardware.

Granted, some of these inconveniences could be overcome with a little
automation.  Even so, if we want to spend our time as developers,
rather than system administrators, it's useful to keep interaction
with our devices at a minimum.

Fortunately, as you may have guessed from seeing the contents of the
+cucumber.wire+ file, you're free to specify a server running on a
different machine.

--------------------------------------------------------------------
host: mytesthardware.example.com
port: 3901
--------------------------------------------------------------------

Now, you can copy your step definition DLL down to the hardware and
run the server there.  Rather than using the +cuke4nuke.bat+ wrapper
script (which also runs the tests), you'll want to run the server
+.exe+ directly:

--------------------------------------------------------------------
C:\MyHardware\> Cuke4Nuke.Server.exe WaveformSteps.dll
--------------------------------------------------------------------

On your PC, you then use just the regular +cucumber+ batch file to run
the tests:

--------------------------------------------------------------------
C:\MyProject\> cucumber
--------------------------------------------------------------------

TODO: Show how to put the step defs on the hardware

Touch-Screen GUI
~~~~~~~~~~~~~~~~

Now, we move from the desktop to the sometimes desktop-like world of
touch-screen GUIs.

.A touch-screen GUI
image::images/touchscreen.png[]

Show the basics of how Cucumber works.  Explain Win32 API connection.

********************************************************************
[quote, Bryan O'Sullivan, 'http://bit.ly/cobolfetish[blog comment (2009)]']
____________________________________________________________________
Oh wow.  I never knew that Rubyists had a Cobol fetish.
____________________________________________________________________
********************************************************************


Physical UI
~~~~~~~~~~~

Remote commands to simulate button pushes.

What to do in embedded GUIs? Developer hooks! Show TCP-driven GUI
example, which just happens to be reusable as a test for the official
PI.  All but the most restrictive environments support some kind of PI.


Experiment
----------

How low can it scale? With the official wire protocol, you can drive
anything with TCP.  Or you can use whatever homebrewed protocol your
device supports, and write the glue code yourself.  Demo with something
really cheesy built on an Arduino:

--------------------------------------------------------------------
Given I am ambivalent
When my mood improves
Then I am happy
--------------------------------------------------------------------

An example step definition:

[source,ruby]
--------------------------------------------------------------------
When /^my mood improves$/ do
  @dut.increase_happiness
end
--------------------------------------------------------------------

5 LEDs representing moods, up/down buttons.  Simulate by sending +/- to
serial port.  Query LED state as bit mask by sending ? character.  Get
good correspondence between GUI / serial, then test largely w/o
hardware.

Another example: use multiline strings to represent menu text on the
four-line display of an LCD---that's what I wish I'd done way back
when.  Similar examples: lawn sprinkler controllers, home automation,
etc.

Now we've run the gamut from ``desktop OS shoehorned into instrument,''
through ``program running on embedded OS'' to ``barely anything running
at all.'' Surely your project fits somewhere on this spectrum.  Well,
except that there's some kind of vertical axis.  Avionics projects have
their own stringent model-checking requirements, for instance.

[source,ruby]
--------------------------------------------------------------------
Given /^I am neutral$/ do
  port_str = '/dev/tty.usbserial-A800ek9T'
  baud_rate = 9600
  data_bits = 8
  stop_bits = 1
  parity = SerialPort::NONE

  @sp = SerialPort.new(port_str, baud_rate, data_bits, stop_bits, parity)
  @sp.read_timeout = 100
  @sp.putc '!' while @sp.read != '!'
end

When /^I increase my happiness$/ do
  @sp.putc '+'
end

Then /^I should be happy$/ do
  @sp.putc '?'
  @sp.read.to_i.should == Happy
end
--------------------------------------------------------------------

Polyglot Testing
----------------

Just for fun, a low-end ``Cucumber lite'' in Tcl.  But there's really no
need.  Cucumber can drive Tcl directly.

Thoughts
--------

Hooks are the single place where a little developer time has a huge
impact.  I wasn't sure enough of myself to pester people to add this
stuff at first.

Decide what you want from your tests.  Exercise the GUI? Top-to-bottom
testing? Document the requirements?

Choose a notation that lets you express your intent clearly.

Think of BDD as a rallying cry or an inspirational card on your desk,
not as a checklist of practices.
